; 3 7 15 19 20 30 32 44 45 46

;#3
;Определите функцию, заменяющую в исходном списке все вхождения заданного значения другими

(print "-----TASK 3-----")

(defun rep (lst pattern replaceWith)
	(
    	(lambda(head tail)
    	
            (cond 
        		(
        			(null lst)
        			nil
        		)
        	    (
        	        (eq head pattern) 
        		    (cons replaceWith (rep tail pattern replaceWith))
        		)
    		    (t
    		        (cons head (rep tail pattern replaceWith))
    		    )
    		)
    	)
    	(car lst)(cdr lst)
	)
)

;Test cases
(print (rep '(1 2 3 1 1) 1 'a))
;(A 2 3 A A) 
(print (rep '((1 2 3) 4 5 6 1) 1 44))
;((1 2 3) 4 5 6 44) 
  
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#7
;Определите функцию, удаляющую из исходного списка элементы с четными номерами.
(print "-----TASK 7-----")
(defun drop-eventh (w)
	(cond 
		((null w) nil)
		(t 
			(cons
				(car w)
				(drop-eventh (cddr w))
			)
		)
	)
) 

;Test cases        
(print (drop-eventh '(1 2 3 4 5 6 7 (8 81))))
;(1 3 5 7) 		
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#15
;Определите функцию, вычисляющую скалярное произведение векторов, заданных списками целых чисел.

(print "-----TASK 15-----")
(defun cross-prod(v1 v2)
	(cond
		((null v1) 0)
		((null v2) 0)
		(t (+ (* (car v1) (car v2)) (cross-prod(cdr v1) (cdr v2))))
	)
)

;Test cases
(print(cross-prod '(2 3 5) '(3 7 9)))
; 72 
(print(cross-prod '(2 3 5) '(3 7 9 2 5)))
; 72 
(print(cross-prod '(2 3 5 7 9) '(3 7 9)))
; 72 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#19
;Определите функцию (ЛУКОВИЦА n), строящую N-уровневый вложенный список, элементом которого на самом глубоком уровне является N.

(print "-----TASK 19-----")
(defun ЛУКОВИЦА (n &optional (nn n))
	(cond 
		((= n 1) (list nn))
		(t 
			(list (ЛУКОВИЦА (- n 1) nn))
		)
	)
)

;Test cases

(print (ЛУКОВИЦА 1))
; (1)
(print (ЛУКОВИЦА 2))
; ((2))
(print (ЛУКОВИЦА 5))
; (((((5)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#20
;Определите функцию ПЕРВЫЙ-АТОМ, результатом которой будет первый атом списка. Пример:
;> (ПЕРВЫЙ-АТОМ ’(((a b)) c d))
;A
(print "-----TASK 20-----")

(defun ПЕРВЫЙ-АТОМ(lst)
	(cond
        (
			(atom lst) 
			lst
		)
		(t 
			(ПЕРВЫЙ-АТОМ (car lst))
		)
    )
)

;Test cases

(print (ПЕРВЫЙ-АТОМ '(1)))
; 1
(print (ПЕРВЫЙ-АТОМ '((+ 1 2) 5)))
; +

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#30
;Запрограммируйте интерпретатор ВЫЧИСЛИ, который преобразует инфиксную запись операций в префиксную и возвращает значение выражения. Пример:
;> (ВЫЧИСЛИ ’((-2 + 4) * 3))
;6
(print "-----TASK 30-----")

(defun prefix (lst)
   (cond 
		((null lst) nil)
		((atom lst) lst)
		(t
			(list 
				(prefix (cadr lst))
				(prefix (car lst))
				(prefix (caddr lst))
			)
		)
	)
)

(defun ВЫЧИСЛИ (lst)
	(eval (prefix lst))
)

;
;------------------------------------------------------------------------------
;
;(print  (calculate '((-4 + 7 ) *  3 )))
(print (ВЫЧИСЛИ '((-4 + 7 ) *  3 )))
;(print  (calculate '((2 + -6 ) *  4 )))
(print (ВЫЧИСЛИ '((2 + -6 ) *  4 )))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#32
;Определить предикат МНОЖЕСТВО-Р, который проверяет, является ли список множеством, т.е. входит ли каждый элемент в список лишь один раз.

(print "-----TASK 32-----")
(defun is_el_present (lst el)
	(cond
		((null lst)
			nil
		)
		((= (car lst) el)
			t
		)
		(t
			(is_el_present (cdr lst) el)
		)
	)
)

(defun МНОЖЕСТВО-Р (lst)
	(
		(lambda(head tail)
			(cond
				((null lst)
					t
				)
				(
					(is_el_present tail head)
					nil
				)
				(t
					(МНОЖЕСТВО-Р tail)
				)
			)
		)
		(car lst)
		(cdr lst)
	)
)
;Test cases
(print (МНОЖЕСТВО-Р '(1 2 3 4)))
; T
(print (МНОЖЕСТВО-Р '(1 1 3 4)))
; NIL
(print (МНОЖЕСТВО-Р '(1 2 3 4 5 5)))
; NIL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#44
;Определите функцию, проверяющую, является ли одно дерево поддеревом второго.

(print "-----TASK 44-----")
(print "NOT_IMPLEMENTED_YET")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#45
;Предположим, что у имени города есть свойства х и у, которые содержат координаты места нахождения города относительно некоторого начала координат. Напишите функцию (РАССТОЯНИЕ a b), вычисляющую расстояние между городами а и b

(print "-----TASK 45-----")
(print "NOT_IMPLEMENTED_YET")

;#46
;Предположим, что отец и мать некоторого лица, хранятся как значения соответствующих свойств у символа, обозначающего это лицо. Напишите функцию (РОДИТЕЛИ x), которая возвращает в качестве значения родителей, и предикат (СЕСТРЫ-БРАТЬЯ x1 x2), который истинен в случае, если x1 и x2 — сестры или братья, родные или с одним общим родителем
(print "-----TASK 46-----")
(print "NOT_IMPLEMENTED_YET")
