-- 3. Определите функцию, которая разделит исходный список из целых чисел на два списка: список положительных чисел и список отрицательных чисел

split list = (filter (> 0) list,filter (< 0) list)

-- 6. Реализовать функцию обратную к функции из задачи 5.
-- ### 5. Определите функцию, упаковывающую последовательные дубликаты списка в подсписки вида (M N), где N - элемент списка, M - количество повторений. 
-- ### Например, [’a’, ’a’, ’a’, ’a’, ’b’, ’c’, ’c’, ’a’, ’a’, ’d’, ’e’, ’e’, ’e’, ’e’] должен быть переведен в [(4, ’a’), (1, ’b’), (2, ’c’),(2, ’a’), (1, ’d’), (4, ’e’)].

unpack list = concat (map (\x -> replicate (fst x) (snd x)) list)

-- 14. Определите функцию, вычисляющую глубину списка (самой глубокой ветви).

-- 16. Определите предикат МНОЖЕСТВО-Р, который проверяет, является ли список множеством, т.е. входит ли каждый элемент в список лишь один раз.
is_a_set list = length (filter (>1) (map(\x -> (length . filter (==x))list) list)) == 0
-- 24. Определите функцию РАзНОСТь, формирующую разность двух множеств, т.е. удаляющую из первого множества все общие со вторым множеством элементы
:{
deleteFirst _ [] = []
deleteFirst x (h:t) = if (x == h) then t else h : deleteFirst x t

subtractLists :: Eq t => [t] -> [t] -> [t]
subtractLists x [] = x
subtractLists [] _ = []
subtractLists x (y:yt) = if elem y x then subtractLists (deleteFirst y x) yt else subtractLists x yt
:}
subtractLists [1,2,3,4,5] [1]

--3. Реализовать энкодер и декодер для кода Хемминга способного исправлять одну ошибку.

--2. Определите функцию, находящую максимальное из значений, находящихся в вершинах дерева.
