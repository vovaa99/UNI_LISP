-- 3. Определите функцию, которая разделит исходный список из целых чисел на два списка: список положительных чисел и список отрицательных чисел
print("TASK 3")
split list = (filter (> 0) list,filter (< 0) list)
print("TEST CASES")
split [1,2,3,4]
--([1,2,3,4],[])
split [-1,-2,-3,-4]
--([],[-1,-2,-3,-4])
split [1,-1,2,-2,3,-3,4,-4]
--([1,2,3,4],[-1,-2,-3,-4])

----------------------------------------------------
-- 6. Реализовать функцию обратную к функции из задачи 5.
-- ### 5. Определите функцию, упаковывающую последовательные дубликаты списка в подсписки вида (M N), где N - элемент списка, M - количество повторений. 
-- ### Например, ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e'] должен быть переведен в [(4, 'a'), (1, 'b'), (2, 'c'),(2, 'a'), (1, 'd'), (4, 'e')].
print("TASK 6")
unpack list = concat (map (\x -> replicate (fst x) (snd x)) list)
print("TEST CASES")
unpack [(4, 'a'), (1, 'b'), (2, 'c'),(2, 'a'), (1, 'd'), (4, 'e')]
--"aaaabccaadeeee"
unpack [(4, 1), (1, 2), (2, 3),(2, 4), (1, 5), (4, 6)]
--[1,1,1,1,2,3,3,4,4,5,6,6,6,6]
unpack [(4, "12"), (1, "22"), (2, "32"),(2, "42"), (1, "52"), (4, "62")]
--["12","12","12","12","22","32","32","42","42","52","62","62","62","62"]

----------------------------------------------------
-- 14. Определите функцию, вычисляющую глубину списка (самой глубокой ветви).
-- В haskell невозможно создать вложенные списки без создания собственных структур, поэтому будет использоваться стандартный тип Data.Tree
print("TASK 14")
import Data.Tree
import Data.List -- maximum
:{
getDepth :: Tree a -> Int
getDepth (Node _ []) = 1
getDepth (Node _ xs) = 1 + maximum (map getDepth xs)
:}
print("TEST CASES")
getDepth (Node 1 [Node 2 [], Node 3 []])
--2
getDepth (Node 1 [Node 2 [Node 4 []], Node 3 []])
--3
--getDepth (Node 1 [Node 2 [Node 4 []], Node 3 [Node 5[]]])
--3
getDepth (Node 1 [Node 2 [Node 4 [Node 6[]]], Node 3 [Node 5[]]])
--4

----------------------------------------------------
-- 16. Определите предикат МНОЖЕСТВО-Р, который проверяет, является ли список множеством, т.е. входит ли каждый элемент в список лишь один раз.
print("TASK 16")
is_a_set list = length (filter (>1) (map(\x -> (length . filter (==x))list) list)) == 0

print("TEST CASES")
is_a_set [1,2,3]
--True
is_a_set [1,1,2,3]
--False
is_a_set [1,2,1,3]
--False
is_a_set [1,2,3,1]
--False
is_a_set [1,2,2,3]
--False
is_a_set [1,2,3,2]
--False
----------------------------------------------------
-- 24. Определите функцию РАзНОСТь, формирующую разность двух множеств, т.е. удаляющую из первого множества все общие со вторым множеством элементы
print("TASK 24")
:{
deleteFirst _ [] = []
deleteFirst x (h:t) = if (x == h) then t else h : deleteFirst x t

subtractLists :: Eq t => [t] -> [t] -> [t]
subtractLists x [] = x
subtractLists [] _ = []
subtractLists x (y:yt) = if elem y x then subtractLists (deleteFirst y x) yt else subtractLists x yt
:}
print("TEST CASES")
subtractLists [1,2,3,4,5] [1]

--3. Реализовать энкодер и декодер для кода Хемминга способного исправлять одну ошибку.

--2. Определите функцию, находящую максимальное из значений, находящихся в вершинах дерева.
